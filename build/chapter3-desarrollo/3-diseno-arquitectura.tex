
\section{Diseño del Sistema}

\subsection{Visión general de la Arquitectura}

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{figures/architecture-diagram.png}
    \caption{Arquitectura general del sistema PANOT}
    \label{fig:diagrama-arquitectura}
\end{figure}

La arquitectura de PANOT sigue un estilo \textbf{cliente-servidor} con las 
siguientes características distintivas:

{\small
\begin{itemize}
    \item \textbf{Arquitectura Offline-First}: El cliente móvil mantiene 
    una copia local completa de los datos, permitiendo operar sin conexión. 
    La sincronización con el servidor se realiza automáticamente cuando 
    hay conectividad disponible, garantizando disponibilidad del sistema 
    en condiciones de red intermitente.
    
    \item \textbf{Backend as a Service (BaaS)}: Se utiliza Supabase como 
    plataforma de backend, proporcionando autenticación, base de datos 
    PostgreSQL con Row Level Security, y sincronización en tiempo real, 
    sin necesidad de gestionar infraestructura propia.
    
    \item \textbf{Computación Serverless}: Toda la lógica de backend se 
    ejecuta en Supabase Edge Functions, funciones serverless basadas en 
    Deno que se invocan bajo demanda. Esto incluye la integración con 
    servicios externos (Stripe) y el sistema de procesamiento de IA.
    
    \item \textbf{Procesamiento mediante Cola de Trabajos}: Las tareas 
    complejas se encolan en la base de datos y se procesan mediante 
    triggers que invocan las Edge Functions. El modelo de ejecución 
    combina dos niveles:

    \begin{itemize}
        \item \textit{Asíncrono entre usuarios}: Las peticiones de distintos 
        usuarios se procesan en paralelo, sin bloquearse mutuamente.
        \item \textit{Secuencial por usuario}: Cada usuario tiene un worker 
        dedicado que procesa sus tareas en orden, una tras otra, evitando 
        condiciones de carrera sobre sus propios datos.
    \end{itemize}
\end{itemize}
}

\paragraph{\colorbox{Apricot}{Capa Cliente (React Native / Expo)}}
La aplicación móvil se organiza internamente en tres subcapas diferenciadas:

{\small
\begin{itemize}
    \item \textbf{Presentación}: Pantallas y componentes React Native con 
          navegación declarativa mediante Expo Router.
    \item \textbf{Estado}: La gestión del estado se divide en dos capas. 
          Los \textbf{React Contexts} manejan el estado de la interfaz 
          (grabación activa, búsquedas, preferencias de usuario), mientras 
          que \textit{LegendState} gestiona los datos de negocio (contactos, 
          interacciones, perfiles) con persistencia local mediante \textit{AsyncStorage} y sincronización 
          automática con el servidor.
    \item \textbf{Servicios}: Clases especializadas (\textit{ContactsService}, 
          \textit{InteractionsService}, \textit{SemanticNodesService}, 
          \textit{ProcessQueueService} y \textit{ProfilesService}) que encapsulan las operaciones 
          CRUD sobre Supabase, proporcionando una interfaz para consultas y modificaciones de datos.
\end{itemize}
}

Adicionalmente, el módulo nativo y propietario \texttt{panot-speech} expone las \acrshort{api}s de reconocimiento 
de voz de iOS para transcripción en tiempo real, garantizando operabilidad \textit{offline} 
e independencia de servicios externos.

\paragraph{\colorbox{CornflowerBlue}{Capa de Servidor (Supabase)}}
El backend aprovecha los servicios gestionados de Supabase descritos en el anterior 
Capítulo:

{\small
\begin{itemize}
    \item \textbf{Autenticación}: Email con \acrshort{otp} y Apple Sign-In, con gestión 
          automática de tokens \acrshort{jwt}.
    \item \textbf{Base de datos}: Persistencia de datos en PostgreSQL con políticas RLS para aislamiento 
          de datos por usuario y encriptación de datos en transito y en reposo.
    \item \textbf{Realtime}: Suscripciones \gls{websocket} para sincronización 
          entre dispositivos.
    \item \textbf{Triggers de procesamiento}: Disparan Edge Functions al insertar registros 
          en \texttt{process\_queue}, implementando el patrón de cola de mensajes.
\end{itemize}
}

\paragraph{\colorbox{Salmon}{Capa de Procesamiento (Edge Functions)}}
Tres funciones \textit{serverless} implementan la lógica de backend:

{\small
\begin{itemize}
    \item \texttt{stripe-endpoint}: Procesa webhooks de Stripe gestionando el ciclo de vida de suscripciones 
    mediante \gls{payment-intent}, \gls{ephemeral-key} y \gls{stripe-customer}.
    \item \texttt{worker-infra}: Sistema de cola de trabajos que instancia un 
          \textit{worker} por usuario, garantizando procesamiento secuencial 
          y evitando condiciones de carrera.
    \item \texttt{relational-agent}: Orquesta el sistema multi-agente para 
          procesamiento semántico, detallado en la Sección~\ref{sec:sistema-multiagente}.
\end{itemize}
}

La arquitectura del sistema se fundamenta en cinco decisiones clave o ADRs (Architectural Decision Records) que 
condicionan el diseño general:

{\small 
\begin{enumerate}
    \item[\textbf{ADR-1}] \textbf{Arquitectura Offline-First.} Dado que la aplicación 
    se utiliza frecuentemente en contextos de networking (eventos, conferencias, parkings, etc.) con 
    conectividad intermitente, se optó por implementar sincronización \textit{offline-first} 
    mediante \textit{LegendState} y persistencia en \textit{AsyncStorage}. Esta decisión garantiza 
    disponibilidad del 100\% y elimina la latencia percibida al operar con datos locales, 
    aunque introduce complejidad en la resolución de conflictos de sincronización.
    
    \item[\textbf{ADR-2}] \textbf{Supabase como BaaS.} Tratándose de un proyecto individual 
    con recursos limitados que requiere autenticación, base de datos y comunicación en 
    tiempo real, se seleccionó Supabase frente a un backend personalizado. Esta elección 
    reduce significativamente el tiempo de desarrollo, aunque se asume un 
    \gls{vendor-lock-in} parcial como contrapartida.
    
    \item[\textbf{ADR-3}] \textbf{Un Worker por Usuario.} El procesamiento de transcripciones 
    modifica datos del usuario (contactos, grafo semántico), lo que podría generar 
    inconsistencias si múltiples trabajos se ejecutan en paralelo. Por ello, cada usuario 
    dispone de un \textit{worker} dedicado que procesa sus jobs de forma secuencial, 
    garantizando la consistencia de datos a costa de mayor latencia cuando hay muchos 
    trabajos encolados.
    
    \item[\textbf{ADR-4}] \textbf{Sistema Multi-Agente.} El procesamiento semántico requiere 
    capacidades diferenciadas: gestión de contactos y gestión del grafo de conocimiento. 
    Se implementó un orquestador que delega en agentes especializados (\textit{ContactAgent}, 
    \textit{GraphAgent}), permitiendo separación de responsabilidades, prompts especializados 
    y facilidad de extensión, con el \gls{overhead} de coordinación entre agentes como 
    principal desventaja.
    
    \item[\textbf{ADR-5}] \textbf{Edge Functions para Lógica de Backend.} El sistema requiere 
    ejecutar lógica de backend para procesamiento de pagos, gestión de cola de trabajos y 
    procesamiento con \acrshort{ia}. Frente a alternativas como AWS Lambda, Vercel Serverless 
    o Cloudflare Workers, se optó por Supabase Edge Functions (basadas en Deno) por su 
    integración nativa con la base de datos, gateway unificado de \acrshort{api}, capacidad 
    de invocación desde \textit{triggers} de PostgreSQL y facturación por invocación sin 
    costes de servidor inactivo. Como contrapartida, el runtime Deno presenta un ecosistema 
    más reducido que Node.js, existe un límite de ejecución de 150 segundos, y se profundiza 
    el \gls{vendor-lock-in} con Supabase.
\end{enumerate}
}

\subsection{Sistema Multi-Agente para Procesamiento de Información}
\label{sec:sistema-multiagente}

El procesamiento semántico de las interacciones presenta un reto particular. Una misma interacción podría contener 
información de naturaleza muy diversa (datos de contacto, intereses personales, relaciones profesionales, etc.), lo que 
hace imposible predecir qué acciones tomar en cada caso concreto. Para abordar este problema, se ha optado por 
utilizar un sistema Multi-Agente.

A diferencia de un flujo de trabajo lineal, este sistema es capaz de razonar sobre el contenido y escoger qué operaciones 
realizar sobre la información. Además, el sistema de Multi-Agente de PANOT, ofrece ventajas a nivel de \textit{modularidad}, ya que 
cada agente del sistema es especializado en un dominio concreto, y \textit{extensibilidad}, ya que habilita la incorporación de 
nuevas capacidades en forma de herramientas o agentes sin necesidad de modificar el flujo y diseño general.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{figures/multi-agent-diagram.png}
    \caption{Diagrama de la arquitecturadel sistema multi-agente de PANOT}
    \label{fig:diagrama-multi-agente}
\end{figure}

\newpage

El sistema Multi-Agente de PANOT sigue una arquitectura vertical[INCLUIR REFERENCIA], donde un agente orquestador actúa como coordinador central, delegando 
tareas a agentes especializados que reportan sus resultados de vuelta. Esta estructura proporciona control 
centralizado sobre el flujo de ejecución, aislando, como ya se ha comentado, a cada agente en su dominio específico.

\paragraph{Agente Orquestador}

El agente orquestador constituye el punto de entrada del sistema Multi-Angente. El sistema recibe como entrada o bien 
la transcripción de una interacción o bien la nueva descripción de un contacto y, junto con el contexto necesario (\texttt{user\_id}, \texttt{contact\_id}, 
\texttt{node\_id}), determina qué operaciones realizar sobre esta información. El sistema opera en 
tres modos diferenciados:

{\small
\begin{itemize}
    \item \textbf{ACTIONABLE}: Modo predeterminado para el procesamiento de transcripciones. Permite 
    ejecutar acciones de creación y actualización sobre contactos y el grafo contextual.
    \item \textbf{CONTACT\_DETAILS\_UPDATE}: Modo especializado para actualizar únicamente los datos del grafo contextual. Este modo 
    está reservado a aquellos casos en los que el usuario modifica manualmente la descripción de un contacto.
    \item \textbf{CONVERSATIONAL}: Modo reservado para consultas sobre la red de contactos del usuario 
    (por ejemplo, \textit{¿qué sé de este contacto?}). En este modo, la entrada es una pregunta en lenguaje natural del usuario y 
    la salida, de igual manera, es una respuesta en lenguaje natural por parte del sistema, priorizando la recuperación de información existente.
\end{itemize}
}

El orquestador de PANOT analiza el contenido de la entrada y decide qué agentes invocar según la naturaleza 
de la información. Sus herramientas principales son los propios agentes especializados: \texttt{manageContact} 
para operaciones sobre contactos y \texttt{manageContextGraph} para gestión del grafo semántico.

\paragraph{Agente de Contactos - \texttt{manageContact}}

Este agente gestiona el ciclo de vida casi completo de los contactos del usuario. Su dominio abarca 
las operaciones de Crear, Leer y Actualizar sobre el artefacto \textit{Contact} y dispone de las siguientes herramientas:

{\small
\begin{itemize}
    \item \texttt{create\_contact}: Crea un nuevo contacto en la base de datos. Cabe destacar que 
    la creación del nodo semántico asociado (de tipo \texttt{CONTACT}) se delega a un \textit{trigger} 
    de PostgreSQL sobre inserción en la tabla de contactos, manteniendo así la separación de responsabilidades.
    \item \texttt{get\_contact\_data}: Recupera los datos almacenados de un contacto específico, 
    permitiendo al orquestador contextualizar las decisiones posteriores.
    \item \texttt{update\_contact\_details}: Actualiza la información básica del contacto.
\end{itemize}
}

\paragraph{Agente de Grafo Contextual - \texttt{manageContextGraph}}

El agente de grafo contextual gestiona la estructura de conocimiento que representa la información 
semántica de los contactos del usuario. Esta estructura adopta la forma de un grafo donde los nodos representan 
entidades o conceptos y las aristas codifican el tipo de relaciones entre ellos. Como se analiza en la Sección~\ref{sec:grafos-contextuales}, 
la elección de un grafo como modelo de datos permite representar relaciones complejas y multidimensionales que serían 
difíciles de capturar en un modelo relacional tradicional, además de ofrecer ventajas significativas en cuanto a eficiencia. 

El grafo contiene dos tipos principales de nodos: nodos \texttt{CONTACT} (uno por cada contacto del usuario) 
y nodos \texttt{CONCEPT} que representan entidades abstractas o concretas. Ambos tipos de nodos tienen una etiqueta 
asociada que representa el tipo de concepto (Hobby, Empresa, Interés, Ubicación, etc.). Las aristas conectan estos nodos 
mediante relaciones semánticamente tipadas (afiliación, preferencia, espacial, social, etc.)

{\small
\begin{itemize}
    \item \texttt{batch\_add\_info\_to\_graph}: Permite añadir múltiples conceptos 
    (intereses, hobbies, empresas, etc.) al grafo de un contacto en una 
    única invocación. Para cada concepto, aplica la lógica de matching 
    semántico para determinar si el concepto debe reutilizar un nodo ya existente o crear uno nuevo.
    \item \texttt{batch\_delete\_semantic\_nodes}: Elimina múltiples nodos del 
    grafo en una sola operación. Las aristas asociadas se eliminan 
    automáticamente por integridad referencial. Solo opera sobre nodos 
    pertenecientes al usuario especificado. 
    \item \texttt{get\_contact\_context\_from\_graph}: Recupera el grafo completo 
    de conocimiento de un contacto, incluyendo todos los nodos conectados y sus tipos de relación. Indica 
    además si cada nodo es compartido con otros contactos mediante un campo específico denominado \texttt{is\_shared}.
    \item \texttt{find\_shared\_connections\_for\_contact}: Identifica todos los 
    contactos que comparten contexto con un contacto específico. Busca 
    nodos $v$ tales que $weight(v) > 1$ (es decir, su peso es mayor que uno, lo que indica que están conectados a 
    múltiples contactos) y retorna qué otros contactos comparten cada 
    nodo. Esta es la funcionalidad que permite descubrir conexiones 
    no evidentes entre contactos.
    \item \texttt{search\_semantic\_nodes}: Permite buscar nodos existentes en 
    el grafo del usuario filtrando por categoría (Hobby, Empresa, Interés, 
    etc.) o por coincidencia parcial en la etiqueta. Útil para explorar 
    el grafo o verificar la existencia de conceptos antes de añadirlos.
    

\end{itemize}
}

\subsubsection{Matching Semántico}

El sistema utiliza búsqueda vectorial para determinar si existe relación semántica con conceptos ya existentes, 
o si el concepto nuevo debe reutilizar un nodo ya existente o crear uno nuevo. 

Para cada concepto entrante, se genera un \textit{embedding} combinando tres atributos: la etiqueta del nodo, 
su categoría y el tipo de relación (usando el modelo \textit{text-embedding-3-small} de OpenAI). 
Este vector se almacena en PostgreSQL y se compara con los nodos existentes mediante \textit{pgvector}, 
calculando la \textit{similitud coseno} $s$ entre el embedding entrante y los ya almacenados. El 
comportamiento del matching se define formalmente mediante la función: 
\newpage

{\small
\[
\begin{gathered}
\texttt{find\_semantic\_match}: [0,1] \rightarrow \mathcal{A} \quad \text{donde} \quad \\[0.5em]
\texttt{find\_semantic\_match}(s) = 
\begin{cases}
    \text{REUTILIZAR}(n^*) & \text{si } s \geq 0.90 \\[0.5em]
    \text{CREAR} + \text{RELACIONAR}(n^*) & \text{si } 0.47 \leq s < 0.90 \\[0.5em]
    \text{CREAR} & \text{si } s < 0.47
\end{cases}
\end{gathered}
\]

\footnotesize
\noindent donde $n^* = \arg\max_{n \in \mathcal{N}} \text{sim}(\mathbf{e}_{\text{nuevo}}, \mathbf{e}_n)$ 
es el nodo con mayor similitud, $\mathcal{N}$ es el conjunto de nodos semánticos existentes, 
y $\mathcal{A} = \{\text{REUTILIZAR}, \text{CREAR}, \text{RELACIONAR}\}$ es el conjunto de acciones. 
En el primer caso (\textit{match exacto}), se incrementa el peso del nodo $n^*$ y se establece 
la relación desde el contacto. En el segundo caso (\textit{match relacionado}), se crea un nodo 
nuevo con una arista \texttt{RELACIONADO\_CON} hacia $n^*$, preservando la conexión semántica. Y en el 
tercer caso, se crea un nodo nuevo sin conexiones adicionales.
}

Esta estrategia permite descubrir \textbf{conexiones compartidas} entre contactos 
mediante el análisis de caminos en el grafo: dos contactos $C_1$ y $C_2$ están 
conectados cuando comparten un nodo adyacente común (escenario 1, $d(C_1, C_2) = 2$) 
o cuando sus nodos están enlazados mediante una arista \texttt{RELACIONADO\_CON} 
(escenario 2, $d(C_1, C_2) = 3$), priorizando las conexiones de menor distancia 
como indicadores de mayor afinidad. Siendo $d(C_1, C_2)$ la distancia o camino más corto entre los contactos en el grafo.


\subsubsection{Observabilidad}

Para garantizar la trazabilidad del sistema en producción, se ha integrado LangSmith como plataforma 
de observabilidad. Esta herramienta permite monitorizar cada invocación del sistema Multi-Agente de PANOT, 
facilitando el \textit{debugging} de las cadenas de razonamiento y el análisis del uso de herramientas 
por parte de cada agente. 

La observabilidad resulta crítica en sistemas basados en \acrshort{ia}, donde el comportamiento no determinista 
y la opacidad de los modelos dificultan la identificación de errores mediante técnicas tradicionales de depuración. 
Podemos ver un ejemplo de traza en LangSmith en la Figura~\ref{fig:traza-langsmith}. 

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/ejemplo-traza-langsmith.png}
    \caption{Ejemplo de traza en LangSmith mostrando el flujo de ejecución del sistema. 
    Esta vista permite analizar latencias por operación, consumo 
    de tokens en cada llamada al modelo, y verificar que el flujo de razonamiento del agente sea el esperado.}
    \label{fig:traza-langsmith}
\end{figure}




\subsection{Modelado de Procesos}

\subsection{Modelado de Datos}
\label{sec:modelado-datos}


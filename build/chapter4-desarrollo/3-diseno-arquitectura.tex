
\section{Diseño del Sistema}

\subsection{Visión general de la Arquitectura}

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{figures/architecture-diagram.png}
    \caption{Arquitectura general del sistema PANOT}
    \label{fig:diagrama-arquitectura}
\end{figure}

La arquitectura de PANOT sigue un estilo \textbf{cliente-servidor} con las 
siguientes características distintivas:

{\small
\begin{itemize}
    \item \textbf{Arquitectura Offline-First}: El cliente móvil mantiene 
    una copia local completa de los datos, permitiendo operar sin conexión. 
    La sincronización con el servidor se realiza automáticamente cuando 
    hay conectividad disponible, garantizando disponibilidad del sistema 
    en condiciones de red intermitente.
    
    \item \textbf{Backend as a Service (BaaS)}: Se utiliza Supabase como 
    plataforma de backend, proporcionando autenticación, base de datos 
    PostgreSQL con Row Level Security, y sincronización en tiempo real, 
    sin necesidad de gestionar infraestructura propia.
    
    \item \textbf{Computación Serverless}: Toda la lógica de backend se 
    ejecuta en Supabase Edge Functions, funciones serverless basadas en 
    Deno que se invocan bajo demanda. Esto incluye la integración con 
    servicios externos (Stripe) y el sistema de procesamiento de IA.
    
    \item \textbf{Procesamiento mediante Cola de Trabajos}: Las tareas 
    complejas se encolan en la base de datos y se procesan mediante 
    triggers que invocan las Edge Functions. El modelo de ejecución 
    combina dos niveles:

    \begin{itemize}
        \item \textit{Asíncrono entre usuarios}: Las peticiones de distintos 
        usuarios se procesan en paralelo, sin bloquearse mutuamente.
        \item \textit{Secuencial por usuario}: Cada usuario tiene un worker 
        dedicado que procesa sus tareas en orden, una tras otra, evitando 
        condiciones de carrera sobre sus propios datos.
    \end{itemize}
\end{itemize}
}

\paragraph{\colorbox{Apricot}{Capa Cliente (React Native / Expo)}}
La aplicación móvil se organiza internamente en tres subcapas diferenciadas:

{\small
\begin{itemize}
    \item \textbf{Presentación}: Pantallas y componentes React Native con 
          navegación declarativa mediante Expo Router.
    \item \textbf{Estado}: La gestión del estado se divide en dos capas. 
          Los \textbf{React Contexts} manejan el estado de la interfaz 
          (grabación activa, búsquedas, preferencias de usuario), mientras 
          que \textit{LegendState} gestiona los datos de negocio (contactos, 
          interacciones, perfiles) con persistencia local mediante \textit{AsyncStorage} y sincronización 
          automática con el servidor.
    \item \textbf{Servicios}: Clases especializadas (\textit{ContactsService}, 
          \textit{InteractionsService}, \textit{SemanticNodesService}, 
          \textit{ProcessQueueService} y \textit{ProfilesService}) que encapsulan las operaciones 
          CRUD sobre Supabase, proporcionando una interfaz para consultas y modificaciones de datos.
\end{itemize}
}

Adicionalmente, el módulo nativo y propietario \texttt{panot-speech} expone las \acrshort{api}s de reconocimiento 
de voz de iOS para transcripción en tiempo real, garantizando operabilidad \textit{offline} 
e independencia de servicios externos.

\paragraph{\colorbox{CornflowerBlue}{Capa de Servidor (Supabase)}}
El backend aprovecha los servicios gestionados de Supabase descritos en el anterior 
Capítulo:

{\small
\begin{itemize}
    \item \textbf{Autenticación}: Email con \acrshort{otp} y Apple Sign-In, con gestión 
          automática de tokens \acrshort{jwt}.
    \item \textbf{Base de datos}: Persistencia de datos en PostgreSQL con políticas RLS para aislamiento 
          de datos por usuario y encriptación de datos en transito y en reposo.
    \item \textbf{Realtime}: Suscripciones \gls{websocket} para sincronización 
          entre dispositivos.
    \item \textbf{Triggers de procesamiento}: Disparan Edge Functions al insertar registros 
          en \texttt{process\_queue}, implementando el patrón de cola de mensajes.
\end{itemize}
}

\paragraph{\colorbox{Salmon}{Capa de Procesamiento (Edge Functions)}}
Tres funciones \textit{serverless} implementan la lógica de backend:

{\small
\begin{itemize}
    \item \texttt{stripe-endpoint}: Procesa webhooks de Stripe gestionando el ciclo de vida de suscripciones 
    mediante \gls{payment-intent}, \gls{ephemeral-key} y \gls{stripe-customer}.
    \item \texttt{worker-infra}: Sistema de cola de trabajos que instancia un 
          \textit{worker} por usuario, garantizando procesamiento secuencial 
          y evitando condiciones de carrera.
    \item \texttt{relational-agent}: Orquesta el sistema multi-agente para 
          procesamiento semántico, detallado en la Sección~\ref{sec:sistema-multiagente}.
\end{itemize}
}

La arquitectura del sistema se fundamenta en cinco decisiones clave o ADRs (Architectural Decision Records) que 
condicionan el diseño general:

{\small 
\begin{enumerate}
    \item[\textbf{ADR-1}] \textbf{Arquitectura Offline-First.} Dado que la aplicación 
    se utiliza frecuentemente en contextos de networking (eventos, conferencias, parkings, etc.) con 
    conectividad intermitente, se optó por implementar sincronización \textit{offline-first} 
    mediante \textit{LegendState} y persistencia en \textit{AsyncStorage}. Esta decisión garantiza 
    disponibilidad del 100\% y elimina la latencia percibida al operar con datos locales, 
    aunque introduce complejidad en la resolución de conflictos de sincronización.
    
    \item[\textbf{ADR-2}] \textbf{Supabase como BaaS.} Tratándose de un proyecto individual 
    con recursos limitados que requiere autenticación, base de datos y comunicación en 
    tiempo real, se seleccionó Supabase frente a un backend personalizado. Esta elección 
    reduce significativamente el tiempo de desarrollo, aunque se asume un 
    \gls{vendor-lock-in} parcial como contrapartida.
    
    \item[\textbf{ADR-3}] \textbf{Un Worker por Usuario.} El procesamiento de transcripciones 
    modifica datos del usuario (contactos, grafo semántico), lo que podría generar 
    inconsistencias si múltiples trabajos se ejecutan en paralelo. Por ello, cada usuario 
    dispone de un \textit{worker} dedicado que procesa sus jobs de forma secuencial, 
    garantizando la consistencia de datos a costa de mayor latencia cuando hay muchos 
    trabajos encolados.
    
    \item[\textbf{ADR-4}] \textbf{Sistema Multi-Agente.} El procesamiento semántico requiere 
    capacidades diferenciadas: gestión de contactos y gestión del grafo de conocimiento. 
    Se implementó un orquestador que delega en agentes especializados (\textit{ContactAgent}, 
    \textit{GraphAgent}), permitiendo separación de responsabilidades, prompts especializados 
    y facilidad de extensión, con el \gls{overhead} de coordinación entre agentes como 
    principal desventaja.
    
    \item[\textbf{ADR-5}] \textbf{Edge Functions para Lógica de Backend.} El sistema requiere 
    ejecutar lógica de backend para procesamiento de pagos, gestión de cola de trabajos y 
    procesamiento con \acrshort{ia}. Frente a alternativas como AWS Lambda, Vercel Serverless 
    o Cloudflare Workers, se optó por Supabase Edge Functions (basadas en Deno) por su 
    integración nativa con la base de datos, gateway unificado de \acrshort{api}, capacidad 
    de invocación desde \textit{triggers} de PostgreSQL y facturación por invocación sin 
    costes de servidor inactivo. Como contrapartida, el runtime Deno presenta un ecosistema 
    más reducido que Node.js, existe un límite de ejecución de 150 segundos, y se profundiza 
    el \gls{vendor-lock-in} con Supabase.
\end{enumerate}
}

\subsection{Sistema Multi-Agente para Procesamiento de Información}
\label{sec:sistema-multiagente}

El procesamiento semántico de las interacciones presenta un reto particular. Una misma interacción podría contener 
información de naturaleza muy diversa (datos de contacto, intereses personales, relaciones profesionales, etc.), lo que 
hace imposible predecir qué acciones tomar en cada caso concreto. Para abordar este problema, se ha optado por 
utilizar un sistema Multi-Agente.

A diferencia de un flujo de trabajo lineal, este sistema es capaz de razonar sobre el contenido y escoger qué operaciones 
realizar sobre la información. Además, el sistema de Multi-Agente de PANOT, ofrece ventajas a nivel de \textit{modularidad}, ya que 
cada agente del sistema es especializado en un dominio concreto, y \textit{extensibilidad}, ya que habilita la incorporación de 
nuevas capacidades en forma de herramientas o agentes sin necesidad de modificar el flujo y diseño general.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{figures/multi-agent-diagram.png}
    \caption{Diagrama de la arquitecturadel sistema multi-agente de PANOT. En naranje se representa el esquema de la petición enviada al sistema, en morado el Agente \"orquestados\", en Rosa los agentes \"especializados\" y en azul las tablas abstraidas de la base de datos.}
    \label{fig:diagrama-multi-agente}
\end{figure}

\newpage

El sistema Multi-Agente de PANOT sigue una arquitectura vertical[INCLUIR REFERENCIA], donde un agente orquestador actúa como coordinador central, delegando 
tareas a agentes especializados que reportan sus resultados de vuelta. Esta estructura proporciona control 
centralizado sobre el flujo de ejecución, aislando, como ya se ha comentado, a cada agente en su dominio específico.

\paragraph{Agente Orquestador}

El agente orquestador constituye el punto de entrada del sistema Multi-Agente. El sistema recibe como entrada o bien 
la transcripción de una interacción o bien la nueva descripción de un contacto y, junto con el contexto necesario (\texttt{user\_id}, \texttt{contact\_id}, 
\texttt{node\_id}), determina qué operaciones realizar sobre esta información. El sistema opera en 
tres modos diferenciados:

{\small
\begin{itemize}
    \item \textbf{ACTIONABLE}: Modo predeterminado para el procesamiento de transcripciones. Permite 
    ejecutar acciones de creación y actualización sobre contactos y el grafo contextual.
    \item \textbf{CONTACT\_DETAILS\_UPDATE}: Modo especializado para actualizar únicamente los datos del grafo contextual. Este modo 
    está reservado a aquellos casos en los que el usuario modifica manualmente la descripción de un contacto.
    \item \textbf{CONVERSATIONAL}: Modo reservado para consultas sobre la red de contactos del usuario 
    (por ejemplo, \textit{¿qué sé de este contacto?}). En este modo, la entrada es una pregunta en lenguaje natural del usuario y 
    la salida, de igual manera, es una respuesta en lenguaje natural por parte del sistema, priorizando la recuperación de información existente.
\end{itemize}
}

El orquestador de PANOT analiza el contenido de la entrada y decide qué agentes invocar según la naturaleza 
de la información. Sus herramientas principales son los propios agentes especializados: \texttt{manageContact} 
para operaciones sobre contactos y \texttt{manageContextGraph} para gestión del grafo semántico.

\paragraph{Agente de Contactos - \texttt{manageContact}}

Este agente gestiona el ciclo de vida casi completo de los contactos del usuario. Su dominio abarca 
las operaciones de Crear, Leer y Actualizar sobre el artefacto \textit{Contact} y dispone de las siguientes herramientas:

{\small
\begin{itemize}
    \item \texttt{create\_contact}: Crea un nuevo contacto en la base de datos. Cabe destacar que 
    la creación del nodo semántico asociado (de tipo \texttt{CONTACT}) se delega a un \textit{trigger} 
    de PostgreSQL sobre inserción en la tabla de contactos, manteniendo así la separación de responsabilidades.
    \item \texttt{get\_contact\_data}: Recupera los datos almacenados de un contacto específico, 
    permitiendo al orquestador contextualizar las decisiones posteriores.
    \item \texttt{update\_contact\_details}: Actualiza la información básica del contacto.
\end{itemize}
}

\paragraph{Agente de Grafo Contextual - \texttt{manageContextGraph}}

El agente de grafo contextual gestiona la estructura de conocimiento que representa la información 
semántica de los contactos del usuario. Esta estructura adopta la forma de un grafo donde los nodos representan 
entidades o conceptos y las aristas codifican el tipo de relaciones entre ellos. Como se analiza en la Sección~\ref{sec:grafos-contextuales}, 
la elección de un grafo como modelo de datos permite representar relaciones complejas y multidimensionales que serían 
difíciles de capturar en un modelo relacional tradicional, además de ofrecer ventajas significativas en cuanto a eficiencia. 

El grafo contiene dos tipos principales de nodos: nodos \texttt{CONTACT} (uno por cada contacto del usuario) 
y nodos \texttt{CONCEPT} que representan entidades abstractas o concretas. Ambos tipos de nodos tienen una etiqueta 
asociada que representa el tipo de concepto (Hobby, Empresa, Interés, Ubicación, etc.). Las aristas conectan estos nodos 
mediante relaciones semánticamente tipadas (afiliación, preferencia, espacial, social, etc.)

{\small
\begin{itemize}
    \item \texttt{batch\_add\_info\_to\_graph}: Permite añadir múltiples conceptos 
    (intereses, hobbies, empresas, etc.) al grafo de un contacto en una 
    única invocación. Para cada concepto, aplica la lógica de matching 
    semántico para determinar si el concepto debe reutilizar un nodo ya existente o crear uno nuevo.
    \item \texttt{batch\_delete\_semantic\_nodes}: Elimina múltiples nodos del 
    grafo en una sola operación. Las aristas asociadas se eliminan 
    automáticamente por integridad referencial. Solo opera sobre nodos 
    pertenecientes al usuario especificado. 
    \item \texttt{get\_contact\_context\_from\_graph}: Recupera el grafo completo 
    de conocimiento de un contacto, incluyendo todos los nodos conectados y sus tipos de relación. Indica 
    además si cada nodo es compartido con otros contactos mediante un campo específico denominado \texttt{is\_shared}.
    \item \texttt{find\_shared\_connections\_for\_contact}: Identifica todos los 
    contactos que comparten contexto con un contacto específico. Busca 
    nodos $v$ tales que $weight(v) > 1$ (es decir, su peso es mayor que uno, lo que indica que están conectados a 
    múltiples contactos) y retorna qué otros contactos comparten cada 
    nodo. Esta es la funcionalidad que permite descubrir conexiones 
    no evidentes entre contactos.
    \item \texttt{search\_semantic\_nodes}: Permite buscar nodos existentes en 
    el grafo del usuario filtrando por categoría (Hobby, Empresa, Interés, 
    etc.) o por coincidencia parcial en la etiqueta. Útil para explorar 
    el grafo o verificar la existencia de conceptos antes de añadirlos.
\end{itemize}
}

En cuanto a la elección de herramientas, se han implementado funciones basadas en procesamiento por lotes (\textit{batch processing}). 
Este enfoque permite que los agentes procesen múltiples elementos de manera eficiente en una sola operación. Como resultado, se reduce la 
latencia y se optimizan los costes operativos del sistema. 

\subsubsection{Matching Semántico}

El sistema utiliza búsqueda vectorial para determinar si existe relación semántica con conceptos ya existentes, 
o si el concepto nuevo debe reutilizar un nodo ya existente o crear uno nuevo. 

Para cada concepto entrante, se genera un vector, o \textit{embedding} combinando tres atributos: la etiqueta del nodo, 
su categoría y el tipo de relación (usando el modelo \textit{text-embedding-3-small} de OpenAI). 
Este vector se almacena en PostgreSQL y se compara con los nodos existentes mediante \textit{pgvector}, 
calculando la \textit{similitud coseno} $s$ entre el embedding entrante y los ya almacenados. El 
comportamiento del matching se define formalmente mediante la función: 


{\small
\[
\begin{gathered}
\texttt{find\_semantic\_match}: [0,1] \rightarrow \mathcal{A} \quad \text{donde} \quad \\[0.5em]
\texttt{find\_semantic\_match}(s) = 
\begin{cases}
    \text{REUTILIZAR}(n^*) & \text{si } s \geq 0.90 \\[0.5em]
    \text{CREAR} + \text{RELACIONAR}(n^*) & \text{si } 0.47 \leq s < 0.90 \\[0.5em]
    \text{CREAR} & \text{si } s < 0.47
\end{cases}
\end{gathered}
\]
\noindent Donde $s$ es la similitud coseno, $n^* = \arg\max_{n \in \mathcal{N}} \text{sim}(\mathbf{e}_{\text{nuevo}}, \mathbf{e}_n)$ 
es el nodo con mayor similitud, $\mathcal{N}$ es el conjunto de nodos semánticos existentes, 
y $\mathcal{A} = \{\text{REUTILIZAR}, \text{CREAR}, \text{RELACIONAR}\}$ es el conjunto de acciones. 
En el primer caso (\textit{match exacto}), se incrementa el peso del nodo $n^*$ y se establece 
la relación desde el contacto. En el segundo caso (\textit{match relacionado}), se crea un nodo 
nuevo con una arista \texttt{RELACIONADO\_CON} hacia $n^*$, preservando la conexión semántica. Y en el 
tercer caso, se crea un nodo nuevo sin conexiones adicionales.
}

\vspace{.5cm}
Esta estrategia permite descubrir \textbf{conexiones compartidas} entre contactos 
mediante el análisis de caminos en el grafo: dos contactos $C_1$ y $C_2$ están 
conectados cuando comparten un nodo adyacente común (escenario 1, $d(C_1, C_2) = 2$) 
o cuando sus nodos están enlazados mediante una arista \texttt{RELACIONADO\_CON} 
(escenario 2, $d(C_1, C_2) = 3$), priorizando las conexiones de menor distancia 
como indicadores de mayor afinidad. Siendo $d(C_1, C_2)$ la distancia o camino más corto entre los contactos en el grafo.

\newpage
\subsection{Modelado de Datos}
\label{sec:modelado-datos}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=.9\textwidth]{figures/db-modeled.png}
    \caption{Diagrama del modelado de datos de PANOT con los schemas de Supabase \textit{<<public>>} y \textit{<<auth>>}. 
    En el diagrama del schema \textit{<<auth>>} solo se ha incluido la tabla \textit{auth.users} ya que es la unica tabla de el 
    schema que se ha modificado. Y en el diagrama del schema \textit{<<public>>} se ha obviado del diagrama que las claves 
    foráneas \texttt{user\_id} o \texttt{owner\_id} de las tablas provienen del \texttt{id} de la tabla \texttt{users} del 
    schema \textit{<<auth>>}. A modo de ejemplo, solo se ha añadido en la tabla \texttt{profiles} para mantener el diagrama más legible.}
    \label{fig:diagrama-modelado-datos}
\end{figure}

\newpage

El modelo de datos de PANOT se organiza en dos schemas: \textit{<<auth>>} (gestionado por Supabase) y \textit{<<public>>} (lógica de negocio). 
A continuación, se explicarán las entidades del schema \textit{<<public>>}:

\subsubsection{Entidades Principales}

{\small
\begin{itemize}
    \item \texttt{profiles}: Información del perfil de usuario 
    de la aplicación. Cada registro está vinculado a un usuario del schema 
    \textit{<<auth>>} mediante \texttt{user\_id}. Contiene el estado del 
    onboarding y si el usuario tiene suscripción activa o no.
    
    \item \texttt{contacts}: Contactos creados por el usuario. 
    Cada contacto tiene un \texttt{owner\_id} que indica su propietario (usuario creador) y 
    un \texttt{node\_id} que lo vincula con su nodo correspondiente en el 
    grafo semántico correspondiente. El campo \texttt{details} almacena en formato JSON la descripción y detalles
    del contacto, generado manualmente por el usuario o automaticamente por el sistema. 
    
    \item \texttt{interactions}: Transcripciones de voz 
    grabadas por el usuario. El campo \texttt{raw\_content} contiene el 
    texto transcrito. Cada interacción puede estar asociada a un contacto 
    mediante \texttt{contact\_id} o permanecer sin asignar. El campo 
    \texttt{status} indica el estado de procesamiento, que puede ser:
    \begin{itemize}
        \item \texttt{UNPROCESSED}: pendiente de procesar.
        \item \texttt{PROCESSING}: en proceso.
        \item \texttt{PROCESSED}: completado.
    \end{itemize}
\end{itemize}
}

Adicionalmente, se ha incorporado en todas las entidades un campo \texttt{deleted} que implementa el patrón \textit{soft delete}. 
Este mecanismo permite marcar los registros como eliminados de manera lógica en lugar de borrarlos físicamente, 
lo que facilita la recuperación ante eliminaciones accidentales y preserva la integridad referencial entre 
entidades relacionadas. Cabe añadir que este mecanismo ha sido implementado de cara a futuras iteraciones.

\newpage
\subsubsection{Grafo Semántico}

El conocimiento contextual de los contactos se modela como un grafo almacenado en PostgreSQL, compuesto por dos entidades:

{\small
\begin{itemize}
    \item \texttt{semantic\_nodes}: Nodos del grafo. El campo \texttt{type} distingue entre 
    dos tipos: \texttt{CONTACT} (nodo raíz creado automáticamente para cada contacto) y \texttt{CONCEPT} 
    (información contextual como intereses, hobbies, ubicaciones o emociones). El campo \texttt{weight} indica 
    cuántas conexiones tiene el nodo; un valor mayor a uno señala que es compartido por múltiples contactos. 
    El campo \texttt{embedding} almacena el vector generado para búsqueda por similitud semántica. 
    Y el campo \texttt{concept\_category} clasifica el tipo de concepto (Hobby, Interés, Empresa, Emoción, etc.).
    
    \item \texttt{semantic\_edges}: Aristas del grafo. Representa la relación semántica entre dos nodos. Conecta un nodo origen con un nodo destino
    (\texttt{source\_id} $\rightarrow$ \texttt{target\_id}) mediante un tipo de relación (\texttt{relation\_type}). 
\end{itemize}
}

Se ha optado por implementar el grafo directamente en PostgreSQL (\textit{graph-on-SQL}) en lugar de utilizar 
una base de datos de grafos dedicada. La razón principal de esta decisión es evitar la complejidad operativa 
de mantener múltiples motores de bases de datos: un único sistema simplifica el despliegue, las copias de seguridad, 
la monitorización y el mantenimiento general de la infraestructura. Además, para grafos de escala personal 
(cientos a miles de nodos por usuario), PostgreSQL ofrece un rendimiento más que suficiente.

\vspace{.5cm}
\begin{figure}[ht!]
    \centering
    \includegraphics[width=.75\textwidth]{figures/graph-on-sql-showcase.png}
    \caption{Ejemplo de grafo semántico en PostgreSQL. En el se pueden ver dos nodos: un primer nodo A de tipo CONTACT y un segundo nodo B de tipo CONCEPT. 
    Ambos estan conectados con una relación de tipo RELACIONADO\_CON.}
    \label{fig:graph-on-sql-showcase}
\end{figure}


Esta elección trae consigo ventajas adicionales: la integración nativa con Supabase y el resto del modelo de datos, 
el soporte de búsqueda vectorial mediante la extensión \texttt{pgvector} (necesaria para el matching semántico), 
y la posibilidad de ejecutar operaciones sobre el grafo y las entidades relacionales en una misma transacción, 
garantizando la consistencia de los datos.

\subsubsection{Sistema de Procesamiento}

Como se describió en la visión general de la arquitectura, PANOT implementa un modelo de ejecución basado en cola de 
trabajos que combina paralelismo entre usuarios con procesamiento secuencial por usuario. Este patrón se materializa 
en dos entidades:

{\small
\begin{itemize}
    \item \texttt{process\_queue}: Cola de trabajos pendientes. Cada 
    registro representa una tarea a procesar, identificada por su 
    \texttt{job\_type}:
    \begin{itemize}
        \item \texttt{NEW\_CONTACT}: procesar nuevo contacto.
        \item \texttt{INTERACTION\_TRANSCRIPT}: analizar transcripción.
        \item \texttt{DETAILS\_UPDATE}: actualizar resumen del contacto.
    \end{itemize}
    El campo \texttt{status} indica el estado del trabajo:
    \begin{itemize}
        \item \texttt{PENDING}: pendiente de procesar.
        \item \texttt{PROCESSING}: en proceso.
        \item \texttt{COMPLETED}: completado.
        \item \texttt{FAILED}: fallido.
        \item \texttt{CANCELLED}: cancelado.
    \end{itemize}
    El campo \texttt{contact\_id} almacena opcionalmente el identificador 
    del contacto cuando la operación actúa sobre uno específico. El campo 
    \texttt{payload} contiene en formato JSON los datos específicos 
    necesarios para que el sistema Multi-Agente ejecute la tarea. Y en 
    caso de error, el campo \texttt{error\_message} almacena la 
    descripción del fallo.
    
    
    \item \texttt{worker}: Representa el worker dedicado de cada usuario. 
    Cada usuario tiene exactamente un worker (restricción \texttt{UNIQUE} 
    en \texttt{user\_id}). El campo \texttt{status} indica el estado:
    \begin{itemize}
        \item \texttt{idle}: disponible.
        \item \texttt{busy}: procesando una tarea.
    \end{itemize}
    El campo \texttt{last\_activity\_at} registra la última actividad, 
    permitiendo detectar workers bloqueados o inactivos.
\end{itemize}
}

A continuación, se presenta el diagrama de actividad de este sistema de procesamiento por cola. Para mantener la simplicidad se han obviado
datos como actualización de tiempos (\texttt{last\_activity\_at}, \texttt{processed\_at}, \texttt{created\_at} y \texttt{updated\_at}) y el tipo 
de \texttt{PAYLOAD} usado para invocar a \texttt{relational-agent} en función del tipo de trabajo (\texttt{job\_type}). Para ver cómo funciona 
el sistema Multi-Agente, se puede consultar el apartado \ref{sec:sistema-multiagente} anterior.

\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\textwidth]{figures/processing-system-activity-diagram.png}
    \caption{Diagrama de actividad del sistema de procesamiento de PANOT}
    \label{fig:processing-system-activity-diagram}
\end{figure}

\vspace{.5cm}
El diagrama de actividad anterior (\ref{fig:processing-system-activity-diagram}) se centra en el flujo interno de la cola de trabajos. 
Para comprender el flujo completo de procesamiento, es necesario considerar todas las entidades y artefactos involucrados en el sistema. 
A continuación, se presenta un diagrama de secuencia que muestra la interacción entre el cliente móvil, la base de datos, el sistema 
de cola de trabajos (\texttt{process\_queue} y \texttt{worker-infra}) y el sistema Multi-Agente (\texttt{relational-agent}):

\begin{figure}[ht!]
    \centering
    \includegraphics[width=1\textwidth]{figures/process-transcript-sequence-diagram.png}
    \caption{Diagrama de secuencia del procesamiento de una Interacción grabada por el usuario}
    \label{fig:process-transcript-sequence-diagram}
\end{figure}



 